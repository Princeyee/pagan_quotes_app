 
// lib/services/quote_extraction_service.dart - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import 'dart:math';
import 'dart:convert';
import 'package:flutter/services.dart';
import '../models/quote.dart';
import '../models/quote_context.dart';
import '../models/book_source.dart';
import '../models/daily_quote.dart';
import 'text_file_service.dart';
import 'theme_service.dart'; // –î–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç!

class CuratedQuote {
  final String id;
  final String text;
  final String author;
  final String source;
  final String category;
  final int position;
  final bool approved;

  const CuratedQuote({
    required this.id,
    required this.text,
    required this.author,
    required this.source,
    required this.category,
    required this.position,
    required this.approved,
  });

  factory CuratedQuote.fromJson(Map<String, dynamic> json) {
    return CuratedQuote(
      id: json['id'] as String,
      text: json['text'] as String,
      author: json['author'] as String,
      source: json['source'] as String,
      category: json['category'] as String,
      position: json['position'] as int,
      approved: json['approved'] as bool,
    );
  }

  Quote toQuote() {
    return Quote(
      id: id,
      text: text,
      author: author,
      source: source,
      category: category,
      position: position,
      dateAdded: DateTime.now(),
      theme: category,
      isFavorite: false,
    );
  }
}

class QuoteExtractionService {
  static final QuoteExtractionService _instance = QuoteExtractionService._internal();
  factory QuoteExtractionService() => _instance;
  QuoteExtractionService._internal();

  final TextFileService _textService = TextFileService();
  
  // –ö—ç—à –¥–ª—è –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏—Ö —Ü–∏—Ç–∞—Ç
  Map<String, List<CuratedQuote>>? _curatedQuotesCache;

  /// –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏–µ —Ü–∏—Ç–∞—Ç—ã –∏–∑ assets/curated/
  Future<Map<String, List<CuratedQuote>>> _loadCuratedQuotes() async {
    if (_curatedQuotesCache != null) {
      return _curatedQuotesCache!;
    }

    final curatedQuotes = <String, List<CuratedQuote>>{};
    
    // –°–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ —Å –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏–º–∏ —Ü–∏—Ç–∞—Ç–∞–º–∏
    final curatedFiles = [
      'assets/curated/my_quotes_approved.json',
    ];

    for (final filePath in curatedFiles) {
      try {
        print('üìö –ó–∞–≥—Ä—É–∂–∞–µ–º: $filePath');
        final jsonString = await rootBundle.loadString(filePath);
        final List<dynamic> jsonData = json.decode(jsonString);
        
        final quotes = jsonData
            .map((json) => CuratedQuote.fromJson(json as Map<String, dynamic>))
            .where((quote) => quote.approved) // –¢–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ
            .toList();
        
        if (quotes.isNotEmpty) {
          // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
          for (final quote in quotes) {
            curatedQuotes.putIfAbsent(quote.category, () => []).add(quote);
          }
        }
      } catch (e) {
        print('‚ö†Ô∏è –§–∞–π–ª $filePath –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω: $e');
        // –ü—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º - –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ
      }
    }

    // –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    for (final entry in curatedQuotes.entries) {
      print('‚úÖ ${entry.value.length} —Ü–∏—Ç–∞—Ç –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: ${entry.key}');
    }

    _curatedQuotesCache = curatedQuotes;
    return curatedQuotes;
  }

  /// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Ü–∏—Ç–∞—Ç—ã - —Ç–µ–ø–µ—Ä—å –£–ß–ò–¢–´–í–ê–ï–¢ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  Future<DailyQuote?> generateDailyQuote({DateTime? date}) async {
    date ??= DateTime.now();
    
    try {
      print('üé≠ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ü–∏—Ç–∞—Ç—É –Ω–∞ ${date.toString().split(' ')[0]}');
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã–µ —Ü–∏—Ç–∞—Ç—ã
      final curated = await _loadCuratedQuotes();
      
      if (curated.isEmpty) {
        print('‚ùå –ù–µ—Ç –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã—Ö —Ü–∏—Ç–∞—Ç! –ó–∞–ø—É—Å—Ç–∏—Ç–µ quote_curator.dart');
        return null;
      }

      // –í–ê–ñ–ù–û: –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —Ç–µ–º
      final enabledThemes = await ThemeService.getEnabledThemes();
      print('‚úÖ –í–∫–ª—é—á–µ–Ω–Ω—ã–µ —Ç–µ–º—ã: $enabledThemes');
      
      // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–∫–ª—é—á–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
      final availableCategories = curated.keys
          .where((category) => enabledThemes.contains(category))
          .toList();
      
      if (availableCategories.isEmpty) {
        print('‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π! –í—Å–µ —Ç–µ–º—ã –≤—ã–∫–ª—é—á–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º');
        print('üìÇ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏—Ö —Ü–∏—Ç–∞—Ç–∞—Ö: ${curated.keys.toList()}');
        print('üîß –í–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —Ç–µ–º—ã: $enabledThemes');
        
        // –ï—Å–ª–∏ –≤—Å–µ —Ç–µ–º—ã –≤—ã–∫–ª—é—á–µ–Ω—ã, –≤–∫–ª—é—á–∞–µ–º —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        if (curated.keys.isNotEmpty) {
          final defaultCategory = curated.keys.first;
          print('‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: $defaultCategory');
          availableCategories.add(defaultCategory);
        } else {
          return null;
        }
      }
      
      print('üìÇ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: $availableCategories');
      
      // –í—ã–±–∏—Ä–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –¥–Ω—é (—á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ —Å—Ä–µ–¥–∏ –≤–∫–ª—é—á–µ–Ω–Ω—ã—Ö)
      final daysSinceEpoch = date.difference(DateTime(1970)).inDays;
      final categoryIndex = daysSinceEpoch % availableCategories.length;
      final selectedCategory = availableCategories[categoryIndex];
      
      print('üéØ –î–µ–Ω—å $daysSinceEpoch -> –ö–∞—Ç–µ–≥–æ—Ä–∏—è: $selectedCategory');
      
      // –ü–æ–ª—É—á–∞–µ–º —Ü–∏—Ç–∞—Ç—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
      final categoryQuotes = curated[selectedCategory]!;
      
      // –í—ã–±–∏—Ä–∞–µ–º —Ü–∏—Ç–∞—Ç—É —Å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –¥–Ω—è
      final dayRandom = Random(daysSinceEpoch + selectedCategory.hashCode);
      final selectedQuote = categoryQuotes[dayRandom.nextInt(categoryQuotes.length)];
      
      print('üìú –í—ã–±—Ä–∞–Ω–∞: ${selectedQuote.author} - "${selectedQuote.text.substring(0, min(50, selectedQuote.text.length))}..."');
      
      return DailyQuote(
        quote: selectedQuote.toQuote(),
        date: date,
      );
      
    } catch (e) {
      print('‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ü–∏—Ç–∞—Ç—ã: $e');
      return null;
    }
  }

  /// –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è —Ü–∏—Ç–∞—Ç—ã
  Future<QuoteContext?> getQuoteContext(Quote quote) async {
    try {
      print('üîç –ò—â–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Ü–∏—Ç–∞—Ç—ã: ${quote.id}');
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–Ω–∏–≥
      final sources = await _textService.loadBookSources();
      BookSource? matchingSource;
      
      // –ù–∞—Ö–æ–¥–∏–º –∏—Å—Ç–æ—á–Ω–∏–∫ –ø–æ –∞–≤—Ç–æ—Ä—É –∏ –Ω–∞–∑–≤–∞–Ω–∏—é
      for (final source in sources) {
        if (source.author == quote.author && source.title == quote.source) {
          matchingSource = source;
          break;
        }
      }
      
      // Fallback –ø–æ–∏—Å–∫ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –∞–≤—Ç–æ—Ä—É
      if (matchingSource == null) {
        for (final source in sources) {
          if (source.author == quote.author && source.category == quote.category) {
            matchingSource = source;
            break;
          }
        }
      }
      
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π fallback - –ø–æ–∏—Å–∫ –ø–æ —á–∞—Å—Ç–∏—á–Ω–æ–º—É —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é
      if (matchingSource == null) {
        print('‚ö†Ô∏è –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∏—â–µ–º –ø–æ –∞–≤—Ç–æ—Ä—É...');
        for (final source in sources) {
          if (source.author.toLowerCase().contains(quote.author.toLowerCase()) || 
              quote.author.toLowerCase().contains(source.author.toLowerCase())) {
            matchingSource = source;
            print('‚úÖ –ù–∞–π–¥–µ–Ω–æ —á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ: ${source.title}');
            break;
          }
        }
      }
      
      if (matchingSource == null) {
        print('‚ùå –ò—Å—Ç–æ—á–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è: ${quote.author} - ${quote.source}');
        print('üìö –î–æ—Å—Ç—É–ø–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏:');
        for (final s in sources) {
          print('   - ${s.author} : ${s.title} (${s.category})');
        }
        return null;
      }
      
      print('‚úÖ –ù–∞–π–¥–µ–Ω –∏—Å—Ç–æ—á–Ω–∏–∫: ${matchingSource.title} - ${matchingSource.cleanedFilePath}');
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—Å—Ç –∏ –ø–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
      final cleanedText = await _textService.loadTextFile(matchingSource.cleanedFilePath);
      print('üìñ –ó–∞–≥—Ä—É–∂–µ–Ω —Ç–µ–∫—Å—Ç –¥–ª–∏–Ω–æ–π: ${cleanedText.length} —Å–∏–º–≤–æ–ª–æ–≤');
      
      // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤–æ–∫—Ä—É–≥ –ø–æ–∑–∏—Ü–∏–∏ —Ü–∏—Ç–∞—Ç—ã
      final contextParagraphs = _textService.getContextAroundPosition(
        cleanedText, 
        quote.position,
        contextSize: 1, // –ü–æ 1 –ø–∞—Ä–∞–≥—Ä–∞—Ñ—É –¥–æ –∏ –ø–æ—Å–ª–µ
      );
      
      if (contextParagraphs.isEmpty) {
        print('‚ùå –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏: ${quote.position}');
        
        // –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —Ü–∏—Ç–∞—Ç—É –ø–æ —Ç–µ–∫—Å—Ç—É
        print('üîç –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ —Ü–∏—Ç–∞—Ç—É –ø–æ —Ç–µ–∫—Å—Ç—É...');
        final paragraphs = _textService.extractParagraphsWithPositions(cleanedText);
        
        for (final para in paragraphs) {
          final content = para['content'] as String;
          final position = para['position'] as int;
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç —Ü–∏—Ç–∞—Ç—ã –≤ —ç—Ç–æ–º –ø–∞—Ä–∞–≥—Ä–∞—Ñ–µ
          if (content.toLowerCase().contains(quote.text.toLowerCase().substring(0, min(30, quote.text.length)))) {
            print('‚úÖ –ù–∞–π–¥–µ–Ω–∞ —Ü–∏—Ç–∞—Ç–∞ –ø–æ —Ç–µ–∫—Å—Ç—É –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏: $position');
            
            // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –Ω–∞–π–¥–µ–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
            final foundContextParagraphs = _textService.getContextAroundPosition(
              cleanedText, 
              position,
              contextSize: 1,
            );
            
            if (foundContextParagraphs.isNotEmpty) {
              final contextText = foundContextParagraphs
                  .map((p) => p['content'] as String)
                  .join('\n\n');
              
              final startPosition = foundContextParagraphs.first['position'] as int;
              final endPosition = foundContextParagraphs.last['position'] as int;
              
              return QuoteContext(
                quote: quote,
                contextText: contextText,
                startPosition: startPosition,
                endPosition: endPosition,
                contextParagraphs: foundContextParagraphs
                    .map((p) => p['content'] as String)
                    .toList(),
              );
            }
          }
        }
        
        print('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ü–∏—Ç–∞—Ç—É –Ω–∏ –ø–æ –ø–æ–∑–∏—Ü–∏–∏, –Ω–∏ –ø–æ —Ç–µ–∫—Å—Ç—É');
        return null;
      }
      
      final contextText = contextParagraphs
          .map((p) => p['content'] as String)
          .join('\n\n');
      
      final startPosition = contextParagraphs.first['position'] as int;
      final endPosition = contextParagraphs.last['position'] as int;
      
      print('‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–∞–π–¥–µ–Ω: ${contextParagraphs.length} –ø–∞—Ä–∞–≥—Ä–∞—Ñ–æ–≤');
      
      return QuoteContext(
        quote: quote,
        contextText: contextText,
        startPosition: startPosition,
        endPosition: endPosition,
        contextParagraphs: contextParagraphs
            .map((p) => p['content'] as String)
            .toList(),
      );
      
    } catch (e, stackTrace) {
      print('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: $e');
      print('Stack trace: $stackTrace');
      return null;
    }
  }

  // –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
  Future<Quote?> extractRandomQuote(BookSource source, {int? minLength, int? maxLength}) async {
    // –ë–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è - –≤—Å–µ —Ü–∏—Ç–∞—Ç—ã —Ç–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã–µ
    return null;
  }

  Future<List<Quote>> searchQuotes(String query, {int limit = 20}) async {
    // –ú–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–∏—Å–∫ –ø–æ –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã–º —Ü–∏—Ç–∞—Ç–∞–º
    final curated = await _loadCuratedQuotes();
    final allQuotes = <Quote>[];
    
    for (final categoryQuotes in curated.values) {
      for (final curatedQuote in categoryQuotes) {
        final quote = curatedQuote.toQuote();
        if (quote.text.toLowerCase().contains(query.toLowerCase()) ||
            quote.author.toLowerCase().contains(query.toLowerCase()) ||
            quote.source.toLowerCase().contains(query.toLowerCase())) {
          allQuotes.add(quote);
        }
      }
    }
    
    return allQuotes.take(limit).toList();
  }

  Future<Map<String, int>> getExtractionStats() async {
    final curated = await _loadCuratedQuotes();
    final stats = <String, int>{};
    
    for (final entry in curated.entries) {
      stats[entry.key] = entry.value.length;
    }
    
    return stats;
  }
}