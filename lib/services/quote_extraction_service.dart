
// lib/services/quote_extraction_service.dart - –ü–†–û–°–¢–ê–Ø –í–ï–†–°–ò–Ø
import 'dart:math';
import 'dart:convert';
import 'package:flutter/services.dart';
import '../models/quote.dart';
import '../models/quote_context.dart';
import '../models/book_source.dart';
import '../models/daily_quote.dart';
import 'text_file_service.dart';

class CuratedQuote {
  final String id;
  final String text;
  final String author;
  final String source;
  final String category;
  final int position;
  final bool approved;

  const CuratedQuote({
    required this.id,
    required this.text,
    required this.author,
    required this.source,
    required this.category,
    required this.position,
    required this.approved,
  });

  factory CuratedQuote.fromJson(Map<String, dynamic> json) {
    return CuratedQuote(
      id: json['id'] as String,
      text: json['text'] as String,
      author: json['author'] as String,
      source: json['source'] as String,
      category: json['category'] as String,
      position: json['position'] as int,
      approved: json['approved'] as bool,
    );
  }

  Quote toQuote() {
    return Quote(
      id: id,
      text: text,
      author: author,
      source: source,
      category: category,
      position: position,
      dateAdded: DateTime.now(),
      theme: category,
      isFavorite: false,
    );
  }
}

class QuoteExtractionService {
  static final QuoteExtractionService _instance = QuoteExtractionService._internal();
  factory QuoteExtractionService() => _instance;
  QuoteExtractionService._internal();

  final TextFileService _textService = TextFileService();
  
  // –ö—ç—à –¥–ª—è –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏—Ö —Ü–∏—Ç–∞—Ç
  Map<String, List<CuratedQuote>>? _curatedQuotesCache;

  /// –ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏–µ —Ü–∏—Ç–∞—Ç—ã –∏–∑ assets/curated/
  Future<Map<String, List<CuratedQuote>>> _loadCuratedQuotes() async {
    if (_curatedQuotesCache != null) {
      return _curatedQuotesCache!;
    }

    final curatedQuotes = <String, List<CuratedQuote>>{};
    
    // –°–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ —Å –∫—É—Ä–∞—Ç–æ—Ä—Å–∫–∏–º–∏ —Ü–∏—Ç–∞—Ç–∞–º–∏
    final curatedFiles = [
      'assets/curated/aristotle_approved.json',
      'assets/curated/evola_approved.json',
      // –î–æ–±–∞–≤–ª—è–π —Å—é–¥–∞ –Ω–æ–≤—ã–µ —Ñ–∞–π–ª—ã
    ];

    for (final filePath in curatedFiles) {
      try {
        print('üìö –ó–∞–≥—Ä—É–∂–∞–µ–º: $filePath');
        final jsonString = await rootBundle.loadString(filePath);
        final List<dynamic> jsonData = json.decode(jsonString);
        
        final quotes = jsonData
            .map((json) => CuratedQuote.fromJson(json as Map<String, dynamic>))
            .where((quote) => quote.approved) // –¢–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ
            .toList();
        
        if (quotes.isNotEmpty) {
          final category = quotes.first.category;
          curatedQuotes[category] = quotes;
          print('‚úÖ ${quotes.length} —Ü–∏—Ç–∞—Ç –¥–ª—è: $category');
        }
      } catch (e) {
        print('‚ö†Ô∏è –§–∞–π–ª $filePath –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω: $e');
        // –ü—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º - –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ
      }
    }

    _curatedQuotesCache = curatedQuotes;
    return curatedQuotes;
  }

  /// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Ü–∏—Ç–∞—Ç—ã - —Ç–µ–ø–µ—Ä—å –¢–û–õ–¨–ö–û –∏–∑ –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã—Ö
  Future<DailyQuote?> generateDailyQuote({DateTime? date}) async {
    date ??= DateTime.now();
    
    try {
      print('üé≠ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ü–∏—Ç–∞—Ç—É –Ω–∞ ${date.toString().split(' ')[0]}');
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã–µ —Ü–∏—Ç–∞—Ç—ã
      final curated = await _loadCuratedQuotes();
      
      if (curated.isEmpty) {
        print('‚ùå –ù–µ—Ç –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã—Ö —Ü–∏—Ç–∞—Ç! –ó–∞–ø—É—Å—Ç–∏—Ç–µ quote_curator.dart');
        return null;
      }

      final categories = curated.keys.toList();
      print('üìÇ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: $categories');
      
      // –í—ã–±–∏—Ä–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –¥–Ω—é (—á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ)
      final daysSinceEpoch = date.difference(DateTime(1970)).inDays;
      final categoryIndex = daysSinceEpoch % categories.length;
      final selectedCategory = categories[categoryIndex];
      
      print('üéØ –î–µ–Ω—å $daysSinceEpoch -> –ö–∞—Ç–µ–≥–æ—Ä–∏—è: $selectedCategory');
      
      // –ü–æ–ª—É—á–∞–µ–º —Ü–∏—Ç–∞—Ç—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
      final categoryQuotes = curated[selectedCategory]!;
      
      // –í—ã–±–∏—Ä–∞–µ–º —Ü–∏—Ç–∞—Ç—É —Å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –¥–Ω—è
      final dayRandom = Random(daysSinceEpoch + selectedCategory.hashCode);
      final selectedQuote = categoryQuotes[dayRandom.nextInt(categoryQuotes.length)];
      
      print('üìú –í—ã–±—Ä–∞–Ω–∞: ${selectedQuote.author} - "${selectedQuote.text.substring(0, min(50, selectedQuote.text.length))}..."');
      
      return DailyQuote(
        quote: selectedQuote.toQuote(),
        date: date,
      );
      
    } catch (e) {
      print('‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ü–∏—Ç–∞—Ç—ã: $e');
      return null;
    }
  }

  /// –ü–æ–ª—É—á–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Ü–∏—Ç–∞—Ç—ã
  Future<QuoteContext?> getQuoteContext(Quote quote) async {
    try {
      final sources = await _textService.loadBookSources();
      BookSource? matchingSource;
      
      // –ù–∞—Ö–æ–¥–∏–º –∏—Å—Ç–æ—á–Ω–∏–∫
      for (final source in sources) {
        if (source.author == quote.author && source.title == quote.source) {
          matchingSource = source;
          break;
        }
      }
      
      if (matchingSource == null) {
        // Fallback –ø–æ–∏—Å–∫ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –∞–≤—Ç–æ—Ä—É
        for (final source in sources) {
          if (source.author == quote.author && source.category == quote.category) {
            matchingSource = source;
            break;
          }
        }
      }
      
      if (matchingSource == null) {
        print('‚ùå –ò—Å—Ç–æ—á–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è: ${quote.id}');
        return null;
      }
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—Å—Ç –∏ –ø–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
      final cleanedText = await _textService.loadTextFile(matchingSource.cleanedFilePath);
      final contextParagraphs = _textService.getContextAroundPosition(
        cleanedText, 
        quote.position,
        contextSize: 1,
      );
      
      if (contextParagraphs.isEmpty) {
        print('‚ùå –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è: ${quote.id}');
        return null;
      }
      
      final contextText = contextParagraphs
          .map((p) => p['content'] as String)
          .join('\n\n');
      
      final startPosition = contextParagraphs.first['position'] as int;
      final endPosition = contextParagraphs.last['position'] as int;
      
      return QuoteContext(
        quote: quote,
        contextText: contextText,
        startPosition: startPosition,
        endPosition: endPosition,
        contextParagraphs: contextParagraphs
            .map((p) => p['content'] as String)
            .toList(),
      );
      
    } catch (e) {
      print('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: $e');
      return null;
    }
  }

  // –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
  Future<Quote?> extractRandomQuote(BookSource source, {int? minLength, int? maxLength}) async {
    // –ë–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è - –≤—Å–µ —Ü–∏—Ç–∞—Ç—ã —Ç–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –æ—Ç–æ–±—Ä–∞–Ω–Ω—ã–µ
    return null;
  }

  Future<List<Quote>> searchQuotes(String query, {int limit = 20}) async {
    // –ú–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    return [];
  }

  Future<Map<String, int>> getExtractionStats() async {
    // –ú–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    return {};
  }
}